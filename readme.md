> 해당 내용은 [자바 실전 자바 고급 1편 - 김영한](https://www.inflearn.com/courses/lecture?courseId=334352&type=LECTURE&unitId=232340&subtitleLanguage=ko&tab=curriculum) 강의를 듣고 정리했습니다.


## 섹션 3. 스레드 생성과 실행

### 자바 메모리 구조 복습

| 영역         | 설명 |
|--------------|------|
| 메서드 영역  | 프로그램 실행에 필요한 공통 데이터를 관리하는 영역. 모든 클래스에서 공유됨. 클래스 정보(실행 코드, 필드, 메서드, 생성자 등), static 변수, 런타임 상수 풀 등이 존재함 |
| 스택 영역    | 스레드마다 하나씩 생성되는 실행 스택. 지역 변수, 연산 결과, 메서드 호출 정보 등이 포함됨. 메서드 호출 시 스택 프레임이 쌓이고 종료되면 제거됨 |
| 힙 영역      | 객체와 배열이 생성되는 공간. 가비지 컬렉션 대상이 되는 주요 메모리 영역임 |

- 스택 영역은 스레드마다 별도로 생성됨
- 현재는 스레드 1개 사용 → 스택도 1개
- 스레드 수가 늘어나면 스택도 그 수만큼 늘어남

---

### 스레드 생성

- 스레드를 만드는 방법은 두 가지가 있음
    - Thread 클래스를 상속받는 방식
    - Runnable 인터페이스를 구현하는 방식

- 스레드는 실행 순서와 실행 기간이 보장되지 않음 → 이것이 멀티 스레드의 특징임

---

### start() 메서드

- `start()`는 스레드에 스택 공간을 할당하면서 스레드를 시작함
- 새로운 스레드에서 `run()` 메서드를 실행함
- `run()`만 호출하면 main 스레드에서 실행되기 때문에 반드시 `start()`를 사용해야 별도의 스레드에서 실행됨

---

### 데몬 스레드

| 구분           | 설명 |
|----------------|------|
| 사용자 스레드  | 주요 작업을 담당하는 스레드. 모든 사용자 스레드가 종료돼야 JVM이 종료됨 |
| 데몬 스레드    | 백그라운드에서 보조 작업을 수행함. 사용자 스레드가 모두 종료되면 자동으로 종료됨 |

- `setDaemon(true)`로 설정 가능
- `start()` 실행 전에만 설정 가능
- 기본값은 `false` (즉, 사용자 스레드임)

---

### Thread 상속 vs Runnable 구현

| 방식              | 장점 | 단점 |
|------------------|------|------|
| Thread 상속      | 구현이 간단함 (run 메서드만 재정의하면 됨) | 자바는 단일 상속만 허용 → 다른 클래스 상속 중이라면 사용 불가<br>유연성 떨어짐 |
| Runnable 구현    | 상속 제약 없음<br>실행 코드와 스레드 분리 가능 → 가독성 높음<br>여러 스레드가 동일 Runnable 객체 공유 가능 → 자원 관리 효율적 | Thread에 Runnable 객체를 전달하는 구조라 약간 복잡함 |

---

## 섹션 4. 스레드 제어와 생명 주기1

### 스레드의 상태

| 상태 | 설명 |
|------|------|
| **New** | 쓰레드가 생성되었지만 `start()`가 호출되지 않은 상태 |
| **Runnable** | 실행될 준비가 된 상태. CPU에서 실행되거나 스케줄러의 실행 대기열에 있음 |
| **Blocked** | 동기화 락을 얻기 위해 기다리는 상태. 예: `synchronized` 블록 진입 대기 |
| **Waiting** | 다른 쓰레드의 작업을 무기한 기다리는 상태. `wait()`, `join()` 호출 시 진입 |
| **Timed Waiting** | 일정 시간 동안 다른 작업을 기다리는 상태. `sleep()`, `join(시간)` 등 호출 시 |
| **Terminated** | 쓰레드 실행이 끝난 상태. 정상 종료 또는 예외 발생으로 종료됨 |

### 상태 전이

- new → runnable
- runnable → blocked / waiting / timed waiting
- blocked / waiting / timed waiting → runnable
- runnable → terminated

---

### 생명 주기 관련 코드

- `Thread.currentThread()` : 현재 쓰레드 객체 조회
- `Thread.sleep(ms)` : 현재 쓰레드를 `Timed Waiting` 상태로 일정 시간 대기시킴

---

### 체크 예외 재정의 불가

`Runnable` 인터페이스:

```java
public interface Runnable {
    void run();
}
```

`run()`은 체크 예외를 던질 수 없음. 이유는 다음과 같음:

- 부모 메서드(`run()`)가 체크 예외를 던지지 않기 때문에, 자식 메서드도 던질 수 없음
- 자식은 부모가 던지는 예외의 하위 타입만 던질 수 있음
- 언체크 예외는 상관없이 던질 수 있음

**이런 제약이 필요한 이유**  
부모 타입의 메서드를 호출하는 쪽에서는 정해진 예외만 처리하도록 되어 있는데, 자식에서 갑자기 다른 체크 예외를 던지면 클라이언트 코드가 제대로 처리하지 못하는 문제가 생김.  
결과적으로 일관성과 안정성을 지키기 위한 장치임.

**안전한 예외 처리 유도**  
멀티쓰레딩 환경에서는 예외가 적절히 처리되지 않으면 프로그램 전체에 영향을 줄 수 있음. `run()`에서 체크 예외를 강제로 처리하게 하여 예외를 명시적으로 다루도록 유도함.

---

### `join()` 메서드

- `join()` : 호출한 쓰레드는 대상 쓰레드가 종료될 때까지 무한 대기
- `join(ms)` : 호출한 쓰레드는 지정한 시간(ms) 동안만 대기하고 이후 실행 재개

**필요한 상황 예시**  
메인 쓰레드가 다른 작업 쓰레드(`thread-1`, `thread-2`)가 끝나길 기다려야 할 때 사용

| 상황 | 설명 |
|------|------|
| `join()` | 대상 쓰레드가 종료될 때까지 무한 대기 |
| `join(ms)` | 주어진 시간만큼만 대기 후 실행 계속 |

---

## 섹션 5. 스레드 제어와 생명 주기2

### 인터럽트

- `interrupt()`를 호출하면 `WAITING`, `TIMED_WAITING` 같은 **대기 상태의 쓰레드를 깨워서 `RUNNABLE` 상태로 만들 수 있음.**
- 단, `interrupt()` 호출만으로 즉시 `InterruptedException`이 발생하지는 않음  
  → `sleep()` 같은 **예외를 던지는 메서드**가 호출되거나 호출 중일 때만 예외 발생함

#### 인터럽트 상태 처리

- 쓰레드에서 **인터럽트 예외가 한 번 발생하면**, 인터럽트 상태가 `false`로 바뀜
- **인터럽트의 목적을 달성했으면 상태를 다시 정상으로 돌려줘야 함**

| 메서드 | 설명 |
|--------|------|
| `isInterrupted()` | 인터럽트 상태를 확인만 함 (상태 변경 x) |
| `Thread.interrupted()` | 인터럽트 상태를 확인하고, 상태를 `false`로 초기화 |

---

### 프린터 예제

- **`volatile`**: 여러 쓰레드가 동시에 접근하는 변수에 붙이면 **가시성 문제를 해결함**
- **`ConcurrentLinkedQueue`**: 동시성을 지원하는 **컬렉션**, 여러 쓰레드가 안전하게 접근 가능

→ 예제에서는 프린터 큐 작업을 처리하면서 인터럽트를 적용해 쓰레드 안전성과 응답성을 높임

---

### yield() - 양보하기

운영체제가 어떤 쓰레드를 얼마나 실행시킬지는 **스케줄링 정책에 따라 결정됨**.  
특정 쓰레드가 바쁘지 않을 경우, **다른 쓰레드에 CPU 실행 기회를 양보할 수 있음.**

#### 주요 메서드 비교

| 방식 | 설명 | 상태 변화 |
|------|------|------------|
| **empty** | 그냥 자기 일만 쭉 하고 끝냄 | 없음 |
| **sleep(ms)** | 명시적으로 휴식 → 실행 제외 | `RUNNABLE → TIMED_WAITING → RUNNABLE` |
| **yield()** | 양보하고 다시 대기열에 들어감 | `RUNNABLE 유지` |

#### yield() 특징

- `Thread.yield()`는 현재 쓰레드가 **자발적으로 CPU 양보**
- 양보한 쓰레드는 여전히 `RUNNABLE` 상태로 남아서 **다시 스케줄링 큐에 진입**
- 만약 **양보 받을 쓰레드가 없으면**, 본인 쓰레드가 계속 실행될 수도 있음

---

## 섹션 6. 메모리 가시성

### 메모리 가시성이란

멀티쓰레드 환경에서 한 쓰레드가 변경한 값이 다른 쓰레드에서 **언제 보이느냐**의 문제를 **메모리 가시성**이라고 함  
즉, 메모리에 어떤 값이 **보이냐, 보이지 않느냐**에 대한 문제임

---

### 일반적인 예상 vs 실제 메모리 동작

| 구분 | 내용 |
|------|------|
| 일반적인 예상 | main 쓰레드와 work 쓰레드가 각각의 CPU 코어에 할당되어 실행됨 |
| 실제 동작 | 각 CPU는 **캐시 메모리**를 통해 메인 메모리와 별도로 데이터를 접근함 → **각 코어마다 캐시된 값이 다를 수 있음** |

- CPU는 연산 성능을 높이기 위해 **캐시 메모리**를 사용함
- 캐시 메모리는 빠르지만 **작고 비쌈**, 메인 메모리는 **느리지만 크고 쌈**
- runFlag 같이 공유되는 값이 캐시 메모리에만 반영되고, **메인 메모리에 바로 반영되지 않을 수 있음**

---

### 해결책: `volatile`

**volatile** 키워드를 사용하면, 변수의 값을 **항상 메인 메모리에서 읽고 씀**

- CPU의 빠른 연산을 희생해서라도 **정확한 값 공유**가 더 중요할 때 사용
- 여러 쓰레드에서 같은 값을 읽고 쓰는 상황이라면, volatile 키워드를 사용해서 메모리 가시성 문제를 막을 수 있음
- 단, 성능 저하가 있으므로 꼭 필요한 경우에만 사용하는 게 좋음

---

### 자바 메모리 모델 (Java Memory Model, JMM)

JMM은 자바에서 메모리 접근 및 변경에 대한 규칙을 정의한 모델임  
멀티쓰레드 간의 상호작용과 메모리 동기화를 위해 **happens-before** 개념을 사용함

#### happens-before란?

- A 작업이 B 작업보다 먼저 수행되어야 하는 관계를 의미
- A 작업의 메모리 변경은 B 작업에서 반드시 **볼 수 있음**
- happens-before 관계가 보장되면, **한 쓰레드에서 변경한 내용을 다른 쓰레드가 최신 상태로 볼 수 있음**

---

### 메모리 가시성을 확보하는 방법

| 방법 | 설명 |
|------|------|
| `volatile` | 값을 메인 메모리에 강제로 반영하도록 함 |
| `synchronized` | 동기화 블록을 통해 메모리 가시성 보장 |
| `ReentrantLock` | Lock 사용 시 내부적으로 happens-before 관계가 성립됨 |

---

### 정리

- 멀티쓰레드 환경에서는 캐시 메모리 때문에 변수 값이 공유되지 않을 수 있음
- `volatile` 키워드는 메인 메모리 접근을 강제함으로써 메모리 가시성 문제 해결 가능
- JMM의 happens-before 관계를 만족시키면 **메모리 일관성이 보장됨**
- `volatile`, `synchronized`, `ReentrantLock` 등을 활용해서 가시성 문제를 방지할 수 있음

---

## 섹션 7. 동기화 - synchronized

### 동시성 문제

멀티쓰레드를 사용할 때 가장 주의해야 하는 점은, **여러 쓰레드가 동시에 공유 자원에 접근할 때 발생하는 동시성 문제**임  
이런 문제를 막기 위해 **공유 자원에 대한 접근을 적절히 동기화(synchronization)** 해야 함

- 공유 자원: 여러 쓰레드가 동시에 접근하거나 수정하는 자원 (예: 공유 변수, 객체 등)

---

### 임계 영역 (Critical Section)

**임계 영역**은 여러 쓰레드가 동시에 접근하면 문제가 생길 수 있는 중요한 코드 구간을 말함  
공유 자원에 접근하거나 수정하는 부분이 여기에 해당함

- 이 영역은 반드시 **한 번에 하나의 쓰레드만** 접근 가능해야 함
- 그렇지 않으면 데이터 불일치, 예상치 못한 동작 등이 발생함

---

### `synchronized` 키워드

자바에서 `synchronized`를 사용하면 **동기화된 코드 블럭** 또는 **메서드**를 만들 수 있음  
한 번에 하나의 쓰레드만 해당 코드에 진입할 수 있도록 보장해줌

| 구분 | 설명 |
|------|------|
| `synchronized` 메서드 | 메서드 전체를 동기화함 |
| `synchronized` 블럭 | 특정 코드 블럭만 동기화함 (더 정밀하게 제어 가능) |

---

### 락(Lock) 개념

- 모든 자바 객체는 자신만의 **모니터 락(monitor lock)** 을 가지고 있음
- 쓰레드가 `synchronized` 구간에 들어가려면 해당 객체의 락을 **선점**해야 함
- 락을 얻은 쓰레드만 임계 영역을 실행 가능함
- 락 획득 순서는 보장되지 않음

---

### 장단점

| 장점 | 단점 |
|------|------|
| 경합 조건 방지 가능 | 성능 저하 (여러 쓰레드가 동시에 실행 불가) |
| 데이터 일관성 유지 | 병목 현상 발생 가능 |

그래서 `synchronized`는 꼭 필요한 부분에만 사용해야 성능 저하를 최소화할 수 있음

---

### 쓰레드와 메모리

| 항목 | 설명 |
|------|------|
| 스택 영역 | 각 쓰레드가 가지는 **개별 메모리 공간** |
| 지역 변수 | 스택 영역에 생성되며, **다른 쓰레드와 공유되지 않음** |
| 힙 영역의 변수 | 여러 쓰레드에서 공유될 수 있음 → 동기화 필요 |

- 지역 변수는 동기화를 신경 쓸 필요 없음
- 동기화가 필요한 대상은 **공유 자원(힙 영역에 존재)** 에 한정됨

---

### 정리

- 멀티쓰레드 환경에서는 **공유 자원 접근 시 동기화**가 필수임
- `synchronized` 키워드를 사용하면 임계 영역을 보호할 수 있음
- 하지만, 성능 저하가 발생할 수 있으므로 꼭 필요한 경우에만 사용해야 함
- 지역 변수는 공유되지 않기 때문에 동기화 대상이 아님

---
