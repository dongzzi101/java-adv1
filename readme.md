> 해당 내용은 [자바 실전 자바 고급 1편 - 김영한](https://www.inflearn.com/courses/lecture?courseId=334352&type=LECTURE&unitId=232340&subtitleLanguage=ko&tab=curriculum) 강의를 듣고 정리했습니다.


## 섹션 3. 스레드 생성과 실행

### 자바 메모리 구조 복습

| 영역         | 설명 |
|--------------|------|
| 메서드 영역  | 프로그램 실행에 필요한 공통 데이터를 관리하는 영역. 모든 클래스에서 공유됨. 클래스 정보(실행 코드, 필드, 메서드, 생성자 등), static 변수, 런타임 상수 풀 등이 존재함 |
| 스택 영역    | 스레드마다 하나씩 생성되는 실행 스택. 지역 변수, 연산 결과, 메서드 호출 정보 등이 포함됨. 메서드 호출 시 스택 프레임이 쌓이고 종료되면 제거됨 |
| 힙 영역      | 객체와 배열이 생성되는 공간. 가비지 컬렉션 대상이 되는 주요 메모리 영역임 |

- 스택 영역은 스레드마다 별도로 생성됨
- 현재는 스레드 1개 사용 → 스택도 1개
- 스레드 수가 늘어나면 스택도 그 수만큼 늘어남

---

### 스레드 생성

- 스레드를 만드는 방법은 두 가지가 있음
    - Thread 클래스를 상속받는 방식
    - Runnable 인터페이스를 구현하는 방식

- 스레드는 실행 순서와 실행 기간이 보장되지 않음 → 이것이 멀티 스레드의 특징임

---

### start() 메서드

- `start()`는 스레드에 스택 공간을 할당하면서 스레드를 시작함
- 새로운 스레드에서 `run()` 메서드를 실행함
- `run()`만 호출하면 main 스레드에서 실행되기 때문에 반드시 `start()`를 사용해야 별도의 스레드에서 실행됨

---

### 데몬 스레드

| 구분           | 설명 |
|----------------|------|
| 사용자 스레드  | 주요 작업을 담당하는 스레드. 모든 사용자 스레드가 종료돼야 JVM이 종료됨 |
| 데몬 스레드    | 백그라운드에서 보조 작업을 수행함. 사용자 스레드가 모두 종료되면 자동으로 종료됨 |

- `setDaemon(true)`로 설정 가능
- `start()` 실행 전에만 설정 가능
- 기본값은 `false` (즉, 사용자 스레드임)

---

### Thread 상속 vs Runnable 구현

| 방식              | 장점 | 단점 |
|------------------|------|------|
| Thread 상속      | 구현이 간단함 (run 메서드만 재정의하면 됨) | 자바는 단일 상속만 허용 → 다른 클래스 상속 중이라면 사용 불가<br>유연성 떨어짐 |
| Runnable 구현    | 상속 제약 없음<br>실행 코드와 스레드 분리 가능 → 가독성 높음<br>여러 스레드가 동일 Runnable 객체 공유 가능 → 자원 관리 효율적 | Thread에 Runnable 객체를 전달하는 구조라 약간 복잡함 |

---

## 섹션 4. 스레드 제어와 생명 주기1

### 스레드의 상태

| 상태 | 설명 |
|------|------|
| **New** | 쓰레드가 생성되었지만 `start()`가 호출되지 않은 상태 |
| **Runnable** | 실행될 준비가 된 상태. CPU에서 실행되거나 스케줄러의 실행 대기열에 있음 |
| **Blocked** | 동기화 락을 얻기 위해 기다리는 상태. 예: `synchronized` 블록 진입 대기 |
| **Waiting** | 다른 쓰레드의 작업을 무기한 기다리는 상태. `wait()`, `join()` 호출 시 진입 |
| **Timed Waiting** | 일정 시간 동안 다른 작업을 기다리는 상태. `sleep()`, `join(시간)` 등 호출 시 |
| **Terminated** | 쓰레드 실행이 끝난 상태. 정상 종료 또는 예외 발생으로 종료됨 |

### 상태 전이

- new → runnable
- runnable → blocked / waiting / timed waiting
- blocked / waiting / timed waiting → runnable
- runnable → terminated

---

### 생명 주기 관련 코드

- `Thread.currentThread()` : 현재 쓰레드 객체 조회
- `Thread.sleep(ms)` : 현재 쓰레드를 `Timed Waiting` 상태로 일정 시간 대기시킴

---

### 체크 예외 재정의 불가

`Runnable` 인터페이스:

```java
public interface Runnable {
    void run();
}
```

`run()`은 체크 예외를 던질 수 없음. 이유는 다음과 같음:

- 부모 메서드(`run()`)가 체크 예외를 던지지 않기 때문에, 자식 메서드도 던질 수 없음
- 자식은 부모가 던지는 예외의 하위 타입만 던질 수 있음
- 언체크 예외는 상관없이 던질 수 있음

**이런 제약이 필요한 이유**  
부모 타입의 메서드를 호출하는 쪽에서는 정해진 예외만 처리하도록 되어 있는데, 자식에서 갑자기 다른 체크 예외를 던지면 클라이언트 코드가 제대로 처리하지 못하는 문제가 생김.  
결과적으로 일관성과 안정성을 지키기 위한 장치임.

**안전한 예외 처리 유도**  
멀티쓰레딩 환경에서는 예외가 적절히 처리되지 않으면 프로그램 전체에 영향을 줄 수 있음. `run()`에서 체크 예외를 강제로 처리하게 하여 예외를 명시적으로 다루도록 유도함.

---

### `join()` 메서드

- `join()` : 호출한 쓰레드는 대상 쓰레드가 종료될 때까지 무한 대기
- `join(ms)` : 호출한 쓰레드는 지정한 시간(ms) 동안만 대기하고 이후 실행 재개

**필요한 상황 예시**  
메인 쓰레드가 다른 작업 쓰레드(`thread-1`, `thread-2`)가 끝나길 기다려야 할 때 사용

| 상황 | 설명 |
|------|------|
| `join()` | 대상 쓰레드가 종료될 때까지 무한 대기 |
| `join(ms)` | 주어진 시간만큼만 대기 후 실행 계속 |

---

## 섹션 5. 스레드 제어와 생명 주기2

### 인터럽트

- `interrupt()`를 호출하면 `WAITING`, `TIMED_WAITING` 같은 **대기 상태의 쓰레드를 깨워서 `RUNNABLE` 상태로 만들 수 있음.**
- 단, `interrupt()` 호출만으로 즉시 `InterruptedException`이 발생하지는 않음  
  → `sleep()` 같은 **예외를 던지는 메서드**가 호출되거나 호출 중일 때만 예외 발생함

#### 인터럽트 상태 처리

- 쓰레드에서 **인터럽트 예외가 한 번 발생하면**, 인터럽트 상태가 `false`로 바뀜
- **인터럽트의 목적을 달성했으면 상태를 다시 정상으로 돌려줘야 함**

| 메서드 | 설명 |
|--------|------|
| `isInterrupted()` | 인터럽트 상태를 확인만 함 (상태 변경 x) |
| `Thread.interrupted()` | 인터럽트 상태를 확인하고, 상태를 `false`로 초기화 |

---

### 프린터 예제

- **`volatile`**: 여러 쓰레드가 동시에 접근하는 변수에 붙이면 **가시성 문제를 해결함**
- **`ConcurrentLinkedQueue`**: 동시성을 지원하는 **컬렉션**, 여러 쓰레드가 안전하게 접근 가능

→ 예제에서는 프린터 큐 작업을 처리하면서 인터럽트를 적용해 쓰레드 안전성과 응답성을 높임

---

### yield() - 양보하기

운영체제가 어떤 쓰레드를 얼마나 실행시킬지는 **스케줄링 정책에 따라 결정됨**.  
특정 쓰레드가 바쁘지 않을 경우, **다른 쓰레드에 CPU 실행 기회를 양보할 수 있음.**

#### 주요 메서드 비교

| 방식 | 설명 | 상태 변화 |
|------|------|------------|
| **empty** | 그냥 자기 일만 쭉 하고 끝냄 | 없음 |
| **sleep(ms)** | 명시적으로 휴식 → 실행 제외 | `RUNNABLE → TIMED_WAITING → RUNNABLE` |
| **yield()** | 양보하고 다시 대기열에 들어감 | `RUNNABLE 유지` |

#### yield() 특징

- `Thread.yield()`는 현재 쓰레드가 **자발적으로 CPU 양보**
- 양보한 쓰레드는 여전히 `RUNNABLE` 상태로 남아서 **다시 스케줄링 큐에 진입**
- 만약 **양보 받을 쓰레드가 없으면**, 본인 쓰레드가 계속 실행될 수도 있음

---

## 섹션 6. 메모리 가시성

### 메모리 가시성이란

멀티쓰레드 환경에서 한 쓰레드가 변경한 값이 다른 쓰레드에서 **언제 보이느냐**의 문제를 **메모리 가시성**이라고 함  
즉, 메모리에 어떤 값이 **보이냐, 보이지 않느냐**에 대한 문제임

---

### 일반적인 예상 vs 실제 메모리 동작

| 구분 | 내용 |
|------|------|
| 일반적인 예상 | main 쓰레드와 work 쓰레드가 각각의 CPU 코어에 할당되어 실행됨 |
| 실제 동작 | 각 CPU는 **캐시 메모리**를 통해 메인 메모리와 별도로 데이터를 접근함 → **각 코어마다 캐시된 값이 다를 수 있음** |

- CPU는 연산 성능을 높이기 위해 **캐시 메모리**를 사용함
- 캐시 메모리는 빠르지만 **작고 비쌈**, 메인 메모리는 **느리지만 크고 쌈**
- runFlag 같이 공유되는 값이 캐시 메모리에만 반영되고, **메인 메모리에 바로 반영되지 않을 수 있음**

---

### 해결책: `volatile`

**volatile** 키워드를 사용하면, 변수의 값을 **항상 메인 메모리에서 읽고 씀**

- CPU의 빠른 연산을 희생해서라도 **정확한 값 공유**가 더 중요할 때 사용
- 여러 쓰레드에서 같은 값을 읽고 쓰는 상황이라면, volatile 키워드를 사용해서 메모리 가시성 문제를 막을 수 있음
- 단, 성능 저하가 있으므로 꼭 필요한 경우에만 사용하는 게 좋음

---

### 자바 메모리 모델 (Java Memory Model, JMM)

JMM은 자바에서 메모리 접근 및 변경에 대한 규칙을 정의한 모델임  
멀티쓰레드 간의 상호작용과 메모리 동기화를 위해 **happens-before** 개념을 사용함

#### happens-before란?

- A 작업이 B 작업보다 먼저 수행되어야 하는 관계를 의미
- A 작업의 메모리 변경은 B 작업에서 반드시 **볼 수 있음**
- happens-before 관계가 보장되면, **한 쓰레드에서 변경한 내용을 다른 쓰레드가 최신 상태로 볼 수 있음**

---

### 메모리 가시성을 확보하는 방법

| 방법 | 설명 |
|------|------|
| `volatile` | 값을 메인 메모리에 강제로 반영하도록 함 |
| `synchronized` | 동기화 블록을 통해 메모리 가시성 보장 |
| `ReentrantLock` | Lock 사용 시 내부적으로 happens-before 관계가 성립됨 |

---

### 정리

- 멀티쓰레드 환경에서는 캐시 메모리 때문에 변수 값이 공유되지 않을 수 있음
- `volatile` 키워드는 메인 메모리 접근을 강제함으로써 메모리 가시성 문제 해결 가능
- JMM의 happens-before 관계를 만족시키면 **메모리 일관성이 보장됨**
- `volatile`, `synchronized`, `ReentrantLock` 등을 활용해서 가시성 문제를 방지할 수 있음

---

## 섹션 7. 동기화 - synchronized

### 동시성 문제

멀티쓰레드를 사용할 때 가장 주의해야 하는 점은, **여러 쓰레드가 동시에 공유 자원에 접근할 때 발생하는 동시성 문제**임  
이런 문제를 막기 위해 **공유 자원에 대한 접근을 적절히 동기화(synchronization)** 해야 함

- 공유 자원: 여러 쓰레드가 동시에 접근하거나 수정하는 자원 (예: 공유 변수, 객체 등)

---

### 임계 영역 (Critical Section)

**임계 영역**은 여러 쓰레드가 동시에 접근하면 문제가 생길 수 있는 중요한 코드 구간을 말함  
공유 자원에 접근하거나 수정하는 부분이 여기에 해당함

- 이 영역은 반드시 **한 번에 하나의 쓰레드만** 접근 가능해야 함
- 그렇지 않으면 데이터 불일치, 예상치 못한 동작 등이 발생함

---

### `synchronized` 키워드

자바에서 `synchronized`를 사용하면 **동기화된 코드 블럭** 또는 **메서드**를 만들 수 있음  
한 번에 하나의 쓰레드만 해당 코드에 진입할 수 있도록 보장해줌

| 구분 | 설명 |
|------|------|
| `synchronized` 메서드 | 메서드 전체를 동기화함 |
| `synchronized` 블럭 | 특정 코드 블럭만 동기화함 (더 정밀하게 제어 가능) |

---

### 락(Lock) 개념

- 모든 자바 객체는 자신만의 **모니터 락(monitor lock)** 을 가지고 있음
- 쓰레드가 `synchronized` 구간에 들어가려면 해당 객체의 락을 **선점**해야 함
- 락을 얻은 쓰레드만 임계 영역을 실행 가능함
- 락 획득 순서는 보장되지 않음

---

### 장단점

| 장점 | 단점 |
|------|------|
| 경합 조건 방지 가능 | 성능 저하 (여러 쓰레드가 동시에 실행 불가) |
| 데이터 일관성 유지 | 병목 현상 발생 가능 |

그래서 `synchronized`는 꼭 필요한 부분에만 사용해야 성능 저하를 최소화할 수 있음

---

### 쓰레드와 메모리

| 항목 | 설명 |
|------|------|
| 스택 영역 | 각 쓰레드가 가지는 **개별 메모리 공간** |
| 지역 변수 | 스택 영역에 생성되며, **다른 쓰레드와 공유되지 않음** |
| 힙 영역의 변수 | 여러 쓰레드에서 공유될 수 있음 → 동기화 필요 |

- 지역 변수는 동기화를 신경 쓸 필요 없음
- 동기화가 필요한 대상은 **공유 자원(힙 영역에 존재)** 에 한정됨

---

### 정리

- 멀티쓰레드 환경에서는 **공유 자원 접근 시 동기화**가 필수임
- `synchronized` 키워드를 사용하면 임계 영역을 보호할 수 있음
- 하지만, 성능 저하가 발생할 수 있으므로 꼭 필요한 경우에만 사용해야 함
- 지역 변수는 공유되지 않기 때문에 동기화 대상이 아님

---


## 섹션 8. 고급 동기화 - `java.util.concurrent.locks`

### LockSupport

#### `synchronized` 단점

* **무한 대기**: `Blocked` 상태의 쓰레드는 락이 풀릴 때까지 계속 대기함

  * 일정 시간만 대기하거나 중간에 인터럽트하는 기능 없음
* **공정성 부족**: 락이 풀려도 어떤 쓰레드가 락을 획득할지 보장되지 않음

#### LockSupport 기능

LockSupport는 쓰레드를 `waiting` 상태로 전환시킴
→ 깨워줄 때까지 대기하며 CPU 스케줄링에 포함되지 않음

| 메서드                | 설명                                |
| ------------------ | --------------------------------- |
| `park()`           | 쓰레드를 `waiting` 상태로 전환             |
| `parkNanos(nanos)` | 지정한 나노초 동안 `Timed_waiting` 상태로 전환 |
| `unpark(Thread)`   | 해당 쓰레드를 `Runnable` 상태로 깨움         |

#### 인터럽트 처리

* `waiting`, `timed_waiting`: 인터럽트 발생 시 `Runnable` 상태로 전환됨
* `blocked`: 인터럽트가 걸려도 상태에서 빠져나오지 못함

---

### 쓰레드 상태 비교

| 상태              | 설명                                    | 인터럽트 | 예시                                     |
| --------------- | ------------------------------------- | ---- | -------------------------------------- |
| `Blocked`       | 락을 얻기 위해 대기 중인 상태 (`synchronized` 내부) | ×    | `synchronized`                         |
| `Waiting`       | 외부에서 깨워줄 때까지 대기                       | ○    | `Thread.join()`, `Object.wait()`       |
| `Timed_waiting` | 일정 시간 대기                              | ○    | `Thread.sleep(ms)`, `parkNanos(nanos)` |

※ 세 상태 모두 실행 스케줄링에 들어가지 않아서 CPU 입장에서 보면 비활성 상태임
※ `Blocked`는 `synchronized`에서만 쓰는 특별한 상태, 나머지는 범용적으로 사용 가능

---

### ReentrantLock - 이론

`synchronized` 단점을 해결하기 위해 `Lock 인터페이스`를 사용함
대표적인 구현체는 `ReentrantLock`

#### 기본 사용법

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    // 임계 영역
} finally {
    lock.unlock(); // 락 반납 필수
}
```

#### 주요 특징

* `lock()` 호출 시 락을 얻기 전까지 대기 (인터럽트 불가)
* `synchronized`와 다르게 객체 내부의 모니터 락이 아닌 별도 락 사용

---

### 공정성(Fairness)

| 모드                                | 설명             | 특징                                |
| --------------------------------- | -------------- | --------------------------------- |
| 비공정 모드 (`new ReentrantLock()`)    | 락 요청 순서 보장 안 됨 | 성능 우선, 빠르게 락 획득 가능, 기아 현상 발생 가능   |
| 공정 모드 (`new ReentrantLock(true)`) | 락 요청 순서 보장     | 모든 쓰레드가 언젠가 락 획득 가능, 성능 저하 가능성 있음 |

→ `ReentrantLock`은 선택적으로 공정성 보장 모드를 제공함

---

### ReentrantLock - 활용

* `synchronized(this)` 대신 `lock.lock()` 사용 가능
* 임계 영역 종료 후 반드시 `lock.unlock()` 해줘야 함 → 안 하면 다른 쓰레드가 락을 못 얻음

#### 예시

```java
private final Lock lock = new ReentrantLock();

public void criticalSection() {
    lock.lock();
    try {
        // 임계 영역
    } finally {
        lock.unlock();
    }
}
```

※ 내부 락은 `monitor lock`이 아닌 `Lock 인터페이스`가 제공하는 락임

---

### ReentrantLock - 대기 중단 기능

`synchronized`에서는 불가능했던 "락을 기다리지 않고 빠져나오기"가 가능함
→ 락을 얻을 수 없으면 기다리지 않고 바로 다음 로직으로 넘어가는 것도 가능

---

# 섹션 9. 생산자 소비자 문제 1

## 생산자 소비자 문제 - 소개

생산자 소비자 문제는 멀티쓰레드 프로그래밍에서 자주 나오는 동시성 문제임. 여러 쓰레드가 동시에 데이터를 생산하고 소비하는 상황을 다룸.

### 기본 개념

* **생산자 (Producer)** : 데이터를 생성하는 역할
  → 예) 파일에서 데이터를 읽거나, 네트워크에서 데이터를 받아오는 쓰레드가 해당됨

* **소비자 (Consumer)** : 생성된 데이터를 사용하는 역할
  → 예) 데이터를 처리하거나 저장하는 쓰레드가 해당됨

* **버퍼 (Buffer)** : 생산자가 생성한 데이터를 임시로 저장하는 공간
  → 한정된 크기를 가지며, 생산자와 소비자가 이 공간을 통해 데이터를 주고받음

### 문제 상황

| 상황           | 설명                                                         |
| ------------ | ---------------------------------------------------------- |
| 생산자가 너무 빠를 때 | 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없음 → 생산자는 버퍼에 빈 공간이 생길 때까지 대기해야 함 |
| 소비자가 너무 빠를 때 | 버퍼가 비어서 더 이상 소비할 데이터가 없음 → 소비자는 새로운 데이터가 들어올 때까지 대기해야 함    |

---

## 예제 코드 및 분석

### 예제1 코드 및 분석

* 생산자 우선 방식 → 생산자가 먼저 동작할 수 있도록 설계
* 소비자 우선 방식 → 소비자가 먼저 동작할 수 있도록 설계

### 예제2 코드 및 분석

* 생산자, 소비자 간의 더 복잡한 상호작용 처리
* `wait()`과 `notify()`를 활용해 동기화 구현

---

## Object의 wait() / notify() 메서드

### 기본 동작

| 메서드           | 설명                                                                        |
| ------------- | ------------------------------------------------------------------------- |
| `wait()`      | 현재 쓰레드가 가진 락을 반납하고 대기 상태로 전환됨. 반드시 `synchronized` 블록/메서드 안에서 호출되어야 함.     |
| `notify()`    | 대기 중인 쓰레드 중 하나를 깨움. `synchronized` 블록/메서드에서 호출해야 함. 어떤 쓰레드가 깨어날지는 알 수 없음. |
| `notifyAll()` | 대기 중인 모든 쓰레드를 깨움. 역시 `synchronized` 블록/메서드 안에서만 호출 가능함.                   |

* `wait()`을 호출하면 해당 객체의 **대기 집합 (wait set)** 에 들어가게 됨
* 자바에서 모든 객체는 **모니터 락**과 **대기 집합**을 한 쌍으로 가지고 있음

---

## Object.wait(), notify() 방식의 한계

* 하나의 대기 집합에 생산자와 소비자 쓰레드가 모두 섞여서 관리됨
* `notify()`를 호출하면 랜덤으로 하나의 쓰레드를 깨움 →
  큐가 비어 있는데 소비자가 소비자를 깨우거나, 큐가 가득 찼는데 생산자가 생산자를 깨우는 상황이 발생할 수 있음
* → **같은 종류의 쓰레드를 깨우는 비효율**이 발생함

### 쓰레드 기아 (Thread Starvation)

* 어떤 쓰레드가 계속 깨어나지 못하는 문제가 생길 수 있음
* `notify()`가 랜덤으로 쓰레드를 깨우기 때문에 특정 쓰레드가 계속 대기 상태에 머무를 수 있음

### notifyAll()의 필요성

* 모든 쓰레드를 한 번에 깨우면 이러한 문제를 어느 정도 해소할 수 있음
* 하지만 깨어난 쓰레드 중 조건이 맞지 않는 쓰레드는 다시 대기하게 되므로 **불필요한 깨어남**이 발생함

---


