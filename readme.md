> 해당 내용은 [자바 실전 자바 고급 1편 - 김영한](https://www.inflearn.com/courses/lecture?courseId=334352&type=LECTURE&unitId=232340&subtitleLanguage=ko&tab=curriculum) 강의를 듣고 정리했습니다.


## 섹션 3. 스레드 생성과 실행

### 자바 메모리 구조 복습

| 영역         | 설명 |
|--------------|------|
| 메서드 영역  | 프로그램 실행에 필요한 공통 데이터를 관리하는 영역. 모든 클래스에서 공유됨. 클래스 정보(실행 코드, 필드, 메서드, 생성자 등), static 변수, 런타임 상수 풀 등이 존재함 |
| 스택 영역    | 스레드마다 하나씩 생성되는 실행 스택. 지역 변수, 연산 결과, 메서드 호출 정보 등이 포함됨. 메서드 호출 시 스택 프레임이 쌓이고 종료되면 제거됨 |
| 힙 영역      | 객체와 배열이 생성되는 공간. 가비지 컬렉션 대상이 되는 주요 메모리 영역임 |

- 스택 영역은 스레드마다 별도로 생성됨
- 현재는 스레드 1개 사용 → 스택도 1개
- 스레드 수가 늘어나면 스택도 그 수만큼 늘어남

---

### 스레드 생성

- 스레드를 만드는 방법은 두 가지가 있음
    - Thread 클래스를 상속받는 방식
    - Runnable 인터페이스를 구현하는 방식

- 스레드는 실행 순서와 실행 기간이 보장되지 않음 → 이것이 멀티 스레드의 특징임

---

### start() 메서드

- `start()`는 스레드에 스택 공간을 할당하면서 스레드를 시작함
- 새로운 스레드에서 `run()` 메서드를 실행함
- `run()`만 호출하면 main 스레드에서 실행되기 때문에 반드시 `start()`를 사용해야 별도의 스레드에서 실행됨

---

### 데몬 스레드

| 구분           | 설명 |
|----------------|------|
| 사용자 스레드  | 주요 작업을 담당하는 스레드. 모든 사용자 스레드가 종료돼야 JVM이 종료됨 |
| 데몬 스레드    | 백그라운드에서 보조 작업을 수행함. 사용자 스레드가 모두 종료되면 자동으로 종료됨 |

- `setDaemon(true)`로 설정 가능
- `start()` 실행 전에만 설정 가능
- 기본값은 `false` (즉, 사용자 스레드임)

---

### Thread 상속 vs Runnable 구현

| 방식              | 장점 | 단점 |
|------------------|------|------|
| Thread 상속      | 구현이 간단함 (run 메서드만 재정의하면 됨) | 자바는 단일 상속만 허용 → 다른 클래스 상속 중이라면 사용 불가<br>유연성 떨어짐 |
| Runnable 구현    | 상속 제약 없음<br>실행 코드와 스레드 분리 가능 → 가독성 높음<br>여러 스레드가 동일 Runnable 객체 공유 가능 → 자원 관리 효율적 | Thread에 Runnable 객체를 전달하는 구조라 약간 복잡함 |

---

## 섹션 4. 스레드 제어와 생명 주기1

### 스레드의 상태

| 상태 | 설명 |
|------|------|
| **New** | 쓰레드가 생성되었지만 `start()`가 호출되지 않은 상태 |
| **Runnable** | 실행될 준비가 된 상태. CPU에서 실행되거나 스케줄러의 실행 대기열에 있음 |
| **Blocked** | 동기화 락을 얻기 위해 기다리는 상태. 예: `synchronized` 블록 진입 대기 |
| **Waiting** | 다른 쓰레드의 작업을 무기한 기다리는 상태. `wait()`, `join()` 호출 시 진입 |
| **Timed Waiting** | 일정 시간 동안 다른 작업을 기다리는 상태. `sleep()`, `join(시간)` 등 호출 시 |
| **Terminated** | 쓰레드 실행이 끝난 상태. 정상 종료 또는 예외 발생으로 종료됨 |

### 상태 전이

- new → runnable
- runnable → blocked / waiting / timed waiting
- blocked / waiting / timed waiting → runnable
- runnable → terminated

---

### 생명 주기 관련 코드

- `Thread.currentThread()` : 현재 쓰레드 객체 조회
- `Thread.sleep(ms)` : 현재 쓰레드를 `Timed Waiting` 상태로 일정 시간 대기시킴

---

### 체크 예외 재정의 불가

`Runnable` 인터페이스:

```java
public interface Runnable {
    void run();
}
```

`run()`은 체크 예외를 던질 수 없음. 이유는 다음과 같음:

- 부모 메서드(`run()`)가 체크 예외를 던지지 않기 때문에, 자식 메서드도 던질 수 없음
- 자식은 부모가 던지는 예외의 하위 타입만 던질 수 있음
- 언체크 예외는 상관없이 던질 수 있음

**이런 제약이 필요한 이유**  
부모 타입의 메서드를 호출하는 쪽에서는 정해진 예외만 처리하도록 되어 있는데, 자식에서 갑자기 다른 체크 예외를 던지면 클라이언트 코드가 제대로 처리하지 못하는 문제가 생김.  
결과적으로 일관성과 안정성을 지키기 위한 장치임.

**안전한 예외 처리 유도**  
멀티쓰레딩 환경에서는 예외가 적절히 처리되지 않으면 프로그램 전체에 영향을 줄 수 있음. `run()`에서 체크 예외를 강제로 처리하게 하여 예외를 명시적으로 다루도록 유도함.

---

### `join()` 메서드

- `join()` : 호출한 쓰레드는 대상 쓰레드가 종료될 때까지 무한 대기
- `join(ms)` : 호출한 쓰레드는 지정한 시간(ms) 동안만 대기하고 이후 실행 재개

**필요한 상황 예시**  
메인 쓰레드가 다른 작업 쓰레드(`thread-1`, `thread-2`)가 끝나길 기다려야 할 때 사용

| 상황 | 설명 |
|------|------|
| `join()` | 대상 쓰레드가 종료될 때까지 무한 대기 |
| `join(ms)` | 주어진 시간만큼만 대기 후 실행 계속 |

---

## 섹션 5. 스레드 제어와 생명 주기2

### 인터럽트

- `interrupt()`를 호출하면 `WAITING`, `TIMED_WAITING` 같은 **대기 상태의 쓰레드를 깨워서 `RUNNABLE` 상태로 만들 수 있음.**
- 단, `interrupt()` 호출만으로 즉시 `InterruptedException`이 발생하지는 않음  
  → `sleep()` 같은 **예외를 던지는 메서드**가 호출되거나 호출 중일 때만 예외 발생함

#### 인터럽트 상태 처리

- 쓰레드에서 **인터럽트 예외가 한 번 발생하면**, 인터럽트 상태가 `false`로 바뀜
- **인터럽트의 목적을 달성했으면 상태를 다시 정상으로 돌려줘야 함**

| 메서드 | 설명 |
|--------|------|
| `isInterrupted()` | 인터럽트 상태를 확인만 함 (상태 변경 x) |
| `Thread.interrupted()` | 인터럽트 상태를 확인하고, 상태를 `false`로 초기화 |

---

### 프린터 예제

- **`volatile`**: 여러 쓰레드가 동시에 접근하는 변수에 붙이면 **가시성 문제를 해결함**
- **`ConcurrentLinkedQueue`**: 동시성을 지원하는 **컬렉션**, 여러 쓰레드가 안전하게 접근 가능

→ 예제에서는 프린터 큐 작업을 처리하면서 인터럽트를 적용해 쓰레드 안전성과 응답성을 높임

---

### yield() - 양보하기

운영체제가 어떤 쓰레드를 얼마나 실행시킬지는 **스케줄링 정책에 따라 결정됨**.  
특정 쓰레드가 바쁘지 않을 경우, **다른 쓰레드에 CPU 실행 기회를 양보할 수 있음.**

#### 주요 메서드 비교

| 방식 | 설명 | 상태 변화 |
|------|------|------------|
| **empty** | 그냥 자기 일만 쭉 하고 끝냄 | 없음 |
| **sleep(ms)** | 명시적으로 휴식 → 실행 제외 | `RUNNABLE → TIMED_WAITING → RUNNABLE` |
| **yield()** | 양보하고 다시 대기열에 들어감 | `RUNNABLE 유지` |

#### yield() 특징

- `Thread.yield()`는 현재 쓰레드가 **자발적으로 CPU 양보**
- 양보한 쓰레드는 여전히 `RUNNABLE` 상태로 남아서 **다시 스케줄링 큐에 진입**
- 만약 **양보 받을 쓰레드가 없으면**, 본인 쓰레드가 계속 실행될 수도 있음

---

## 섹션 6. 메모리 가시성

### 메모리 가시성이란

멀티쓰레드 환경에서 한 쓰레드가 변경한 값이 다른 쓰레드에서 **언제 보이느냐**의 문제를 **메모리 가시성**이라고 함  
즉, 메모리에 어떤 값이 **보이냐, 보이지 않느냐**에 대한 문제임

---

### 일반적인 예상 vs 실제 메모리 동작

| 구분 | 내용 |
|------|------|
| 일반적인 예상 | main 쓰레드와 work 쓰레드가 각각의 CPU 코어에 할당되어 실행됨 |
| 실제 동작 | 각 CPU는 **캐시 메모리**를 통해 메인 메모리와 별도로 데이터를 접근함 → **각 코어마다 캐시된 값이 다를 수 있음** |

- CPU는 연산 성능을 높이기 위해 **캐시 메모리**를 사용함
- 캐시 메모리는 빠르지만 **작고 비쌈**, 메인 메모리는 **느리지만 크고 쌈**
- runFlag 같이 공유되는 값이 캐시 메모리에만 반영되고, **메인 메모리에 바로 반영되지 않을 수 있음**

---

### 해결책: `volatile`

**volatile** 키워드를 사용하면, 변수의 값을 **항상 메인 메모리에서 읽고 씀**

- CPU의 빠른 연산을 희생해서라도 **정확한 값 공유**가 더 중요할 때 사용
- 여러 쓰레드에서 같은 값을 읽고 쓰는 상황이라면, volatile 키워드를 사용해서 메모리 가시성 문제를 막을 수 있음
- 단, 성능 저하가 있으므로 꼭 필요한 경우에만 사용하는 게 좋음

---

### 자바 메모리 모델 (Java Memory Model, JMM)

JMM은 자바에서 메모리 접근 및 변경에 대한 규칙을 정의한 모델임  
멀티쓰레드 간의 상호작용과 메모리 동기화를 위해 **happens-before** 개념을 사용함

#### happens-before란?

- A 작업이 B 작업보다 먼저 수행되어야 하는 관계를 의미
- A 작업의 메모리 변경은 B 작업에서 반드시 **볼 수 있음**
- happens-before 관계가 보장되면, **한 쓰레드에서 변경한 내용을 다른 쓰레드가 최신 상태로 볼 수 있음**

---

### 메모리 가시성을 확보하는 방법

| 방법 | 설명 |
|------|------|
| `volatile` | 값을 메인 메모리에 강제로 반영하도록 함 |
| `synchronized` | 동기화 블록을 통해 메모리 가시성 보장 |
| `ReentrantLock` | Lock 사용 시 내부적으로 happens-before 관계가 성립됨 |

---

### 정리

- 멀티쓰레드 환경에서는 캐시 메모리 때문에 변수 값이 공유되지 않을 수 있음
- `volatile` 키워드는 메인 메모리 접근을 강제함으로써 메모리 가시성 문제 해결 가능
- JMM의 happens-before 관계를 만족시키면 **메모리 일관성이 보장됨**
- `volatile`, `synchronized`, `ReentrantLock` 등을 활용해서 가시성 문제를 방지할 수 있음

---

## 섹션 7. 동기화 - synchronized

### 동시성 문제

멀티쓰레드를 사용할 때 가장 주의해야 하는 점은, **여러 쓰레드가 동시에 공유 자원에 접근할 때 발생하는 동시성 문제**임  
이런 문제를 막기 위해 **공유 자원에 대한 접근을 적절히 동기화(synchronization)** 해야 함

- 공유 자원: 여러 쓰레드가 동시에 접근하거나 수정하는 자원 (예: 공유 변수, 객체 등)

---

### 임계 영역 (Critical Section)

**임계 영역**은 여러 쓰레드가 동시에 접근하면 문제가 생길 수 있는 중요한 코드 구간을 말함  
공유 자원에 접근하거나 수정하는 부분이 여기에 해당함

- 이 영역은 반드시 **한 번에 하나의 쓰레드만** 접근 가능해야 함
- 그렇지 않으면 데이터 불일치, 예상치 못한 동작 등이 발생함

---

### `synchronized` 키워드

자바에서 `synchronized`를 사용하면 **동기화된 코드 블럭** 또는 **메서드**를 만들 수 있음  
한 번에 하나의 쓰레드만 해당 코드에 진입할 수 있도록 보장해줌

| 구분 | 설명 |
|------|------|
| `synchronized` 메서드 | 메서드 전체를 동기화함 |
| `synchronized` 블럭 | 특정 코드 블럭만 동기화함 (더 정밀하게 제어 가능) |

---

### 락(Lock) 개념

- 모든 자바 객체는 자신만의 **모니터 락(monitor lock)** 을 가지고 있음
- 쓰레드가 `synchronized` 구간에 들어가려면 해당 객체의 락을 **선점**해야 함
- 락을 얻은 쓰레드만 임계 영역을 실행 가능함
- 락 획득 순서는 보장되지 않음

---

### 장단점

| 장점 | 단점 |
|------|------|
| 경합 조건 방지 가능 | 성능 저하 (여러 쓰레드가 동시에 실행 불가) |
| 데이터 일관성 유지 | 병목 현상 발생 가능 |

그래서 `synchronized`는 꼭 필요한 부분에만 사용해야 성능 저하를 최소화할 수 있음

---

### 쓰레드와 메모리

| 항목 | 설명 |
|------|------|
| 스택 영역 | 각 쓰레드가 가지는 **개별 메모리 공간** |
| 지역 변수 | 스택 영역에 생성되며, **다른 쓰레드와 공유되지 않음** |
| 힙 영역의 변수 | 여러 쓰레드에서 공유될 수 있음 → 동기화 필요 |

- 지역 변수는 동기화를 신경 쓸 필요 없음
- 동기화가 필요한 대상은 **공유 자원(힙 영역에 존재)** 에 한정됨

---

### 정리

- 멀티쓰레드 환경에서는 **공유 자원 접근 시 동기화**가 필수임
- `synchronized` 키워드를 사용하면 임계 영역을 보호할 수 있음
- 하지만, 성능 저하가 발생할 수 있으므로 꼭 필요한 경우에만 사용해야 함
- 지역 변수는 공유되지 않기 때문에 동기화 대상이 아님

---


## 섹션 8. 고급 동기화 - `java.util.concurrent.locks`

### LockSupport

#### `synchronized` 단점

* **무한 대기**: `Blocked` 상태의 쓰레드는 락이 풀릴 때까지 계속 대기함

  * 일정 시간만 대기하거나 중간에 인터럽트하는 기능 없음
* **공정성 부족**: 락이 풀려도 어떤 쓰레드가 락을 획득할지 보장되지 않음

#### LockSupport 기능

LockSupport는 쓰레드를 `waiting` 상태로 전환시킴
→ 깨워줄 때까지 대기하며 CPU 스케줄링에 포함되지 않음

| 메서드                | 설명                                |
| ------------------ | --------------------------------- |
| `park()`           | 쓰레드를 `waiting` 상태로 전환             |
| `parkNanos(nanos)` | 지정한 나노초 동안 `Timed_waiting` 상태로 전환 |
| `unpark(Thread)`   | 해당 쓰레드를 `Runnable` 상태로 깨움         |

#### 인터럽트 처리

* `waiting`, `timed_waiting`: 인터럽트 발생 시 `Runnable` 상태로 전환됨
* `blocked`: 인터럽트가 걸려도 상태에서 빠져나오지 못함

---

### 쓰레드 상태 비교

| 상태              | 설명                                    | 인터럽트 | 예시                                     |
| --------------- | ------------------------------------- | ---- | -------------------------------------- |
| `Blocked`       | 락을 얻기 위해 대기 중인 상태 (`synchronized` 내부) | ×    | `synchronized`                         |
| `Waiting`       | 외부에서 깨워줄 때까지 대기                       | ○    | `Thread.join()`, `Object.wait()`       |
| `Timed_waiting` | 일정 시간 대기                              | ○    | `Thread.sleep(ms)`, `parkNanos(nanos)` |

※ 세 상태 모두 실행 스케줄링에 들어가지 않아서 CPU 입장에서 보면 비활성 상태임
※ `Blocked`는 `synchronized`에서만 쓰는 특별한 상태, 나머지는 범용적으로 사용 가능

---

### ReentrantLock - 이론

`synchronized` 단점을 해결하기 위해 `Lock 인터페이스`를 사용함
대표적인 구현체는 `ReentrantLock`

#### 기본 사용법

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    // 임계 영역
} finally {
    lock.unlock(); // 락 반납 필수
}
```

#### 주요 특징

* `lock()` 호출 시 락을 얻기 전까지 대기 (인터럽트 불가)
* `synchronized`와 다르게 객체 내부의 모니터 락이 아닌 별도 락 사용

---

### 공정성(Fairness)

| 모드                                | 설명             | 특징                                |
| --------------------------------- | -------------- | --------------------------------- |
| 비공정 모드 (`new ReentrantLock()`)    | 락 요청 순서 보장 안 됨 | 성능 우선, 빠르게 락 획득 가능, 기아 현상 발생 가능   |
| 공정 모드 (`new ReentrantLock(true)`) | 락 요청 순서 보장     | 모든 쓰레드가 언젠가 락 획득 가능, 성능 저하 가능성 있음 |

→ `ReentrantLock`은 선택적으로 공정성 보장 모드를 제공함

---

### ReentrantLock - 활용

* `synchronized(this)` 대신 `lock.lock()` 사용 가능
* 임계 영역 종료 후 반드시 `lock.unlock()` 해줘야 함 → 안 하면 다른 쓰레드가 락을 못 얻음

#### 예시

```java
private final Lock lock = new ReentrantLock();

public void criticalSection() {
    lock.lock();
    try {
        // 임계 영역
    } finally {
        lock.unlock();
    }
}
```

※ 내부 락은 `monitor lock`이 아닌 `Lock 인터페이스`가 제공하는 락임

---

### ReentrantLock - 대기 중단 기능

`synchronized`에서는 불가능했던 "락을 기다리지 않고 빠져나오기"가 가능함
→ 락을 얻을 수 없으면 기다리지 않고 바로 다음 로직으로 넘어가는 것도 가능

---

# 섹션 9. 생산자 소비자 문제 1

## 생산자 소비자 문제 - 소개

생산자 소비자 문제는 멀티쓰레드 프로그래밍에서 자주 나오는 동시성 문제임. 여러 쓰레드가 동시에 데이터를 생산하고 소비하는 상황을 다룸.

### 기본 개념

* **생산자 (Producer)** : 데이터를 생성하는 역할
  → 예) 파일에서 데이터를 읽거나, 네트워크에서 데이터를 받아오는 쓰레드가 해당됨

* **소비자 (Consumer)** : 생성된 데이터를 사용하는 역할
  → 예) 데이터를 처리하거나 저장하는 쓰레드가 해당됨

* **버퍼 (Buffer)** : 생산자가 생성한 데이터를 임시로 저장하는 공간
  → 한정된 크기를 가지며, 생산자와 소비자가 이 공간을 통해 데이터를 주고받음

### 문제 상황

| 상황           | 설명                                                         |
| ------------ | ---------------------------------------------------------- |
| 생산자가 너무 빠를 때 | 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없음 → 생산자는 버퍼에 빈 공간이 생길 때까지 대기해야 함 |
| 소비자가 너무 빠를 때 | 버퍼가 비어서 더 이상 소비할 데이터가 없음 → 소비자는 새로운 데이터가 들어올 때까지 대기해야 함    |

---

## 예제 코드 및 분석

### 예제1 코드 및 분석

* 생산자 우선 방식 → 생산자가 먼저 동작할 수 있도록 설계
* 소비자 우선 방식 → 소비자가 먼저 동작할 수 있도록 설계

### 예제2 코드 및 분석

* 생산자, 소비자 간의 더 복잡한 상호작용 처리
* `wait()`과 `notify()`를 활용해 동기화 구현

---

## Object의 wait() / notify() 메서드

### 기본 동작

| 메서드           | 설명                                                                        |
| ------------- | ------------------------------------------------------------------------- |
| `wait()`      | 현재 쓰레드가 가진 락을 반납하고 대기 상태로 전환됨. 반드시 `synchronized` 블록/메서드 안에서 호출되어야 함.     |
| `notify()`    | 대기 중인 쓰레드 중 하나를 깨움. `synchronized` 블록/메서드에서 호출해야 함. 어떤 쓰레드가 깨어날지는 알 수 없음. |
| `notifyAll()` | 대기 중인 모든 쓰레드를 깨움. 역시 `synchronized` 블록/메서드 안에서만 호출 가능함.                   |

* `wait()`을 호출하면 해당 객체의 **대기 집합 (wait set)** 에 들어가게 됨
* 자바에서 모든 객체는 **모니터 락**과 **대기 집합**을 한 쌍으로 가지고 있음

---

## Object.wait(), notify() 방식의 한계

* 하나의 대기 집합에 생산자와 소비자 쓰레드가 모두 섞여서 관리됨
* `notify()`를 호출하면 랜덤으로 하나의 쓰레드를 깨움 →
  큐가 비어 있는데 소비자가 소비자를 깨우거나, 큐가 가득 찼는데 생산자가 생산자를 깨우는 상황이 발생할 수 있음
* → **같은 종류의 쓰레드를 깨우는 비효율**이 발생함

### 쓰레드 기아 (Thread Starvation)

* 어떤 쓰레드가 계속 깨어나지 못하는 문제가 생길 수 있음
* `notify()`가 랜덤으로 쓰레드를 깨우기 때문에 특정 쓰레드가 계속 대기 상태에 머무를 수 있음

### notifyAll()의 필요성

* 모든 쓰레드를 한 번에 깨우면 이러한 문제를 어느 정도 해소할 수 있음
* 하지만 깨어난 쓰레드 중 조건이 맞지 않는 쓰레드는 다시 대기하게 되므로 **불필요한 깨어남**이 발생함

---

## 섹션 10. 생산자 소비자 문제2

### Lock Condition - 예제4

#### `Condition`

```java
Condition condition = lock.newCondition();
```

* `ReentrantLock`을 사용하는 쓰레드가 대기할 수 있는 대기 공간임
* `lock.newCondition()` 호출 시 쓰레드 대기 공간이 만들어짐
* `Object.wait()`과 달리 `Condition`은 직접 생성해줘야 함
  (모든 객체가 내부적으로 기본 제공하는 wait-notify 메커니즘과 차이 있음)

#### 주요 메서드

* `condition.await()`:
  → `Object.wait()` 과 유사. 현재 쓰레드를 condition 대기 공간에 보관하며, lock도 반납함.

* `condition.signal()`:
  → `Object.notify()` 와 유사. 대기 중인 쓰레드 하나를 깨워 대기 공간에서 빠져나오게 함.

---

### ✅ 생산자 소비자 대기 공간 분리 - 예제5

#### 쓰레드 대기 공간 분리

* `consumerCond`: 소비자를 위한 대기 공간
* `producerCond`: 생산자를 위한 대기 공간

→ 각각 따로 만들면 필요한 조건에서만 신호를 보낼 수 있음

---

### ✅ Object.notify() vs Condition.signal()

| 구분       | Object.notify()                          | Condition.signal()           |
| -------- | ---------------------------------------- | ---------------------------- |
| 대기 중 쓰레드 | 임의의 하나                                   | FIFO 순서(일반적으로)               |
| 사용 조건    | synchronized 블록 안에서 모니터 락을 가진 쓰레드만 호출 가능 | ReentrantLock을 가진 쓰레드만 호출 가능 |
| 구조       | JVM 구현에 따라 다름                            | 내부적으로 Queue 구조 사용            |

---

### ✅ 스레드의 대기 상태 정리

#### synchronized의 대기 상태

1. **락 획득 대기 (Blocked)**

  * `synchronized` 시작 시 락 없으면 대기
  * 다른 쓰레드가 빠져나올 때까지 대기

2. **wait() 대기 (Waiting)**

  * `wait()` 호출 시 쓰레드 대기 집합에서 대기
  * `notify()` 호출되면 빠져나옴

#### ReentrantLock의 대기 상태

1. **락 획득 대기**

  * `lock.lock()` 호출 → 락 없으면 대기 큐에서 대기
  * 다른 쓰레드가 `unlock()` 해야 락 획득 가능

2. **await() 대기**

  * `condition.await()` 호출 시 해당 condition 대기 공간에서 대기
  * `condition.signal()` 로 깨어남

---

### ✅ synchronized 구조의 핵심 개념 정리

자바 객체는 내부적으로 아래 3가지를 기본으로 가짐

* 모니터 락
* 락 대기 집합
* 쓰레드 대기 집합

→ 이걸 쉽게 비유하자면

* **락 대기 집합**: 1차 대기소
* **쓰레드 대기 집합**: 2차 대기소

즉, `wait()`을 호출하면 2차 대기소로 이동하고 `notify()`에 의해 깨어나도 다시 1차 대기소(Blocked 상태)에서 락을 기다려야 함

---

### ✅ BlockingQueue 개념 정리

`BlockingQueue`는 자바에서 생산자-소비자 문제를 해결하기 위한 특수 큐임

#### 특징

* **데이터 추가 차단**: 큐가 가득 차면 추가 요청한 쓰레드는 대기
* **데이터 획득 차단**: 큐가 비어있으면 데이터를 얻으려는 쓰레드는 대기

#### 대표 구현체

| 구현체                   | 설명                    |
| --------------------- | --------------------- |
| `ArrayBlockingQueue`  | 배열 기반, 고정 크기          |
| `LinkedBlockingQueue` | 링크 기반, 크기 제한 없이 사용 가능 |

---

### ✅ BlockingQueue의 다양한 기능

| 작업 종류 | 예외 발생       | 즉시 반환      | 대기       | 시간만큼 대기                |
| ----- | ----------- | ---------- | -------- | ---------------------- |
| 삽입    | `add(e)`    | `offer(e)` | `put(e)` | `offer(e, time, unit)` |
| 제거    | `remove()`  | `poll()`   | `take()` | `poll(time, unit)`     |
| 조회    | `element()` | `peek()`   | ❌        | ❌                      |

---

### ✅ BlockingQueue - 예외 및 즉시 반환 예시

* `offer(data)` → 성공 시 `true`, 가득 차면 `false` 즉시 반환

* `poll()` → 데이터 없으면 `null` 즉시 반환

* `offer(data, 시간)` → 대기 후 성공 시 `true`, 실패 시 `false`

* `poll(시간)` → 대기 후 데이터 없으면 `null` 반환

* `add(data)` → 가득 차 있으면 예외 발생

* `remove()` → 데이터 없으면 예외 발생

---

## 섹션 11. CAS - 동기화와 원자적 연산

### 원자적 연산 - 소개

원자적 연산이란 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 걸 의미함.
즉, 중단되지 않고 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 특성을 가짐

---

### 원자적 연산 - volatile, synchronized

* `volatile`: 캐시 메모리가 아닌 메인 메모리에 직접 접근함
  → 가시성 문제는 해결되지만, 원자성이나 임계구역 보호는 안됨
* `synchronized`: 임계 구역을 만들어서 동기화 시켜주는 키워드임. 멀티쓰레드 환경에서도 안전하게 동작할 수 있도록 보장함

---

### 원자적 연산 - AtomicInteger

* 멀티쓰레드 상황에서도 안전하게 사용 가능
* 다양한 연산 메서지들 제공 (add, increment 등)
* 특정 값을 여러 쓰레드가 공유하며 증가/감소할 때 적합함

---

### 원자적 연산 - 성능 테스트

| 방식            | 설명                                             | 멀티쓰레드 안전성 | 성능         |
| ------------- | ---------------------------------------------- | --------- | ---------- |
| BasicInteger  | CPU 캐시 사용, 가장 빠름<br>volatile, synchronized 안 씀 | ❌         | ✅ (단일 쓰레드) |
| volatile      | 메인 메모리 직접 접근, 가시성 확보<br>임계구역 없음                | ❌         | ⚠          |
| synchronized  | 안전한 임계 구역 확보                                   | ✅         | ❌          |
| AtomicInteger | 자바 제공 원자적 연산 클래스<br>락 없이 동기화, 멀티쓰레드 안전         | ✅         | ✅          |

---

### CAS 연산1

락 기반 방식의 문제점

* 예: `SyncInteger` 같은 클래스는 `synchronized`나 `ReentrantLock`을 사용해서 락 걸음
* 락이 걸리면 다른 쓰레드가 해당 자원에 접근 못 하고 기다려야 함 → 병목 생김

**CAS(compare-and-swap)**

* 락 없이 원자적 연산을 수행하는 방식
* 락을 사용하지 않기 때문에 락 프리(lock-free) 기법이라고 함
* 단 모든 경우에 쓰기보단 일부 영역, 짧은 로직에 적합함

---

### CAS 연산2, 3

CAS 방식은 락을 걸지 않기 때문에 빠르지만 동시에 여러 쓰레드가 접근할 경우 재시도를 반복해야 함

* 루프를 돌며 재시도 → 성능 저하 가능
* CPU 자원을 많이 씀

#### CAS vs Lock 방식 비교

| 방식   | 접근 방식 | 동작 방식             | 충돌 처리        |
| ---- | ----- | ----------------- | ------------ |
| Lock | 비관적   | 접근 전 락을 먼저 걸고 실행  | 다른 쓰레드 접근 차단 |
| CAS  | 낙관적   | 바로 실행 후, 충돌 시 재시도 | 루프 돌며 재시도    |

---

### CAS 락 구현

* CAS를 이용해 락처럼 동작하는 로직 구현 가능
* 하지만 오래 걸리는 로직에서는 스핀 락 방식(CPU를 점유하며 반복 재시도) 사용하면 CPU 자원 낭비 심함
* 따라서 긴 작업에는 CAS보다 락을 사용하는 게 적절함

---

다음은 섹션 12 "동시성 컬렉션"에 대한 내용을 깃허브 README에 올릴 수 있도록 정리한 버전임. 표와 설명은 최대한 깔끔하고 네 말투에 맞춰 정리했음:

---

## 섹션 12. 동시성 컬렉션

### 동시성 컬렉션이 필요한 이유

기존 컬렉션 프레임워크의 연산들은 대부분 **원자적이지 않음**
멀티쓰레드 환경에서 동시에 접근하면 **데이터 불일치나 예외**가 발생할 수 있음

---

### 동기화와 프록시 패턴

* 자바에서는 `Collections.synchronizedXXX()` 같은 메서드로 동기화된 래퍼를 제공함
* 내부적으로는 **프록시(Proxy) 객체**를 생성해서 동기화를 대신 처리함

**프록시 패턴 요약:**

| 목적       | 설명                            |
| -------- | ----------------------------- |
| 접근 제어    | 실제 객체 접근을 제한하거나 통제            |
| 성능 향상    | 객체 생성을 지연시키거나 캐싱              |
| 부가 기능 제공 | 로깅, 인증, 동기화 등 추가 기능을 프록시에서 처리 |

하지만 `synchronizedList` 같은 방식은 컬렉션 전체에 락을 걸기 때문에 **오버헤드 크고 정교한 동기화 어려움**

---

### 자바의 동시성 컬렉션

멀티쓰레드 환경에서도 안전하게 사용할 수 있는 컬렉션을 자바에서 별도로 제공함
→ `java.util.concurrent` 패키지에 있음

**동시성 컬렉션 종류**

| 종류    | 클래스명                    | 기존 컬렉션 대안   | 특징                              |
| ----- | ----------------------- | ----------- | ------------------------------- |
| List  | `CopyOnWriteArrayList`  | `ArrayList` | 읽기 성능 좋고 쓰기 시 전체 복사 발생          |
| Set   | `CopyOnWriteArraySet`   | `HashSet`   | 내부적으로 `CopyOnWriteArrayList` 사용 |
| Set   | `ConcurrentSkipListSet` | `TreeSet`   | 정렬된 순서 유지, `Comparator` 사용 가능   |
| Map   | `ConcurrentHashMap`     | `HashMap`   | 락을 세분화하여 성능 향상                  |
| Map   | `ConcurrentSkipListMap` | `TreeMap`   | 정렬된 순서 유지, `Comparator` 사용 가능   |
| Queue | `ConcurrentLinkedQueue` | 없음          | 비 차단 방식의 동시성 큐                  |
| Deque | `ConcurrentLinkedDeque` | 없음          | 비 차단 방식의 동시성 데크                 |

---

### 정리

* 일반 컬렉션은 멀티쓰레드 환경에서 위험함
* `Collections.synchronizedXXX()`는 전체 락을 걸어 성능 이슈 있음
* 동시성 컬렉션은 보다 **정교한 락 분할** 또는 **비 차단 알고리즘** 사용으로 성능과 안정성 모두 확보할 수 있음

---

