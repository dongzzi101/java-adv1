> 해당 내용은 [자바 실전 자바 고급 1편 - 김영한](https://www.inflearn.com/courses/lecture?courseId=334352&type=LECTURE&unitId=232340&subtitleLanguage=ko&tab=curriculum) 강의를 듣고 정리했습니다.


## 섹션 3. 스레드 생성과 실행

### 자바 메모리 구조 복습

| 영역         | 설명 |
|--------------|------|
| 메서드 영역  | 프로그램 실행에 필요한 공통 데이터를 관리하는 영역. 모든 클래스에서 공유됨. 클래스 정보(실행 코드, 필드, 메서드, 생성자 등), static 변수, 런타임 상수 풀 등이 존재함 |
| 스택 영역    | 스레드마다 하나씩 생성되는 실행 스택. 지역 변수, 연산 결과, 메서드 호출 정보 등이 포함됨. 메서드 호출 시 스택 프레임이 쌓이고 종료되면 제거됨 |
| 힙 영역      | 객체와 배열이 생성되는 공간. 가비지 컬렉션 대상이 되는 주요 메모리 영역임 |

- 스택 영역은 스레드마다 별도로 생성됨
- 현재는 스레드 1개 사용 → 스택도 1개
- 스레드 수가 늘어나면 스택도 그 수만큼 늘어남

---

### 스레드 생성

- 스레드를 만드는 방법은 두 가지가 있음
    - Thread 클래스를 상속받는 방식
    - Runnable 인터페이스를 구현하는 방식

- 스레드는 실행 순서와 실행 기간이 보장되지 않음 → 이것이 멀티 스레드의 특징임

---

### start() 메서드

- `start()`는 스레드에 스택 공간을 할당하면서 스레드를 시작함
- 새로운 스레드에서 `run()` 메서드를 실행함
- `run()`만 호출하면 main 스레드에서 실행되기 때문에 반드시 `start()`를 사용해야 별도의 스레드에서 실행됨

---

### 데몬 스레드

| 구분           | 설명 |
|----------------|------|
| 사용자 스레드  | 주요 작업을 담당하는 스레드. 모든 사용자 스레드가 종료돼야 JVM이 종료됨 |
| 데몬 스레드    | 백그라운드에서 보조 작업을 수행함. 사용자 스레드가 모두 종료되면 자동으로 종료됨 |

- `setDaemon(true)`로 설정 가능
- `start()` 실행 전에만 설정 가능
- 기본값은 `false` (즉, 사용자 스레드임)

---

### Thread 상속 vs Runnable 구현

| 방식              | 장점 | 단점 |
|------------------|------|------|
| Thread 상속      | 구현이 간단함 (run 메서드만 재정의하면 됨) | 자바는 단일 상속만 허용 → 다른 클래스 상속 중이라면 사용 불가<br>유연성 떨어짐 |
| Runnable 구현    | 상속 제약 없음<br>실행 코드와 스레드 분리 가능 → 가독성 높음<br>여러 스레드가 동일 Runnable 객체 공유 가능 → 자원 관리 효율적 | Thread에 Runnable 객체를 전달하는 구조라 약간 복잡함 |

---

## 섹션 4. 스레드 제어와 생명 주기1

### 스레드의 상태

| 상태 | 설명 |
|------|------|
| **New** | 쓰레드가 생성되었지만 `start()`가 호출되지 않은 상태 |
| **Runnable** | 실행될 준비가 된 상태. CPU에서 실행되거나 스케줄러의 실행 대기열에 있음 |
| **Blocked** | 동기화 락을 얻기 위해 기다리는 상태. 예: `synchronized` 블록 진입 대기 |
| **Waiting** | 다른 쓰레드의 작업을 무기한 기다리는 상태. `wait()`, `join()` 호출 시 진입 |
| **Timed Waiting** | 일정 시간 동안 다른 작업을 기다리는 상태. `sleep()`, `join(시간)` 등 호출 시 |
| **Terminated** | 쓰레드 실행이 끝난 상태. 정상 종료 또는 예외 발생으로 종료됨 |

### 상태 전이

- new → runnable
- runnable → blocked / waiting / timed waiting
- blocked / waiting / timed waiting → runnable
- runnable → terminated

---

### 생명 주기 관련 코드

- `Thread.currentThread()` : 현재 쓰레드 객체 조회
- `Thread.sleep(ms)` : 현재 쓰레드를 `Timed Waiting` 상태로 일정 시간 대기시킴

---

### 체크 예외 재정의 불가

`Runnable` 인터페이스:

```java
public interface Runnable {
    void run();
}
```

`run()`은 체크 예외를 던질 수 없음. 이유는 다음과 같음:

- 부모 메서드(`run()`)가 체크 예외를 던지지 않기 때문에, 자식 메서드도 던질 수 없음
- 자식은 부모가 던지는 예외의 하위 타입만 던질 수 있음
- 언체크 예외는 상관없이 던질 수 있음

**이런 제약이 필요한 이유**  
부모 타입의 메서드를 호출하는 쪽에서는 정해진 예외만 처리하도록 되어 있는데, 자식에서 갑자기 다른 체크 예외를 던지면 클라이언트 코드가 제대로 처리하지 못하는 문제가 생김.  
결과적으로 일관성과 안정성을 지키기 위한 장치임.

**안전한 예외 처리 유도**  
멀티쓰레딩 환경에서는 예외가 적절히 처리되지 않으면 프로그램 전체에 영향을 줄 수 있음. `run()`에서 체크 예외를 강제로 처리하게 하여 예외를 명시적으로 다루도록 유도함.

---

### `join()` 메서드

- `join()` : 호출한 쓰레드는 대상 쓰레드가 종료될 때까지 무한 대기
- `join(ms)` : 호출한 쓰레드는 지정한 시간(ms) 동안만 대기하고 이후 실행 재개

**필요한 상황 예시**  
메인 쓰레드가 다른 작업 쓰레드(`thread-1`, `thread-2`)가 끝나길 기다려야 할 때 사용

| 상황 | 설명 |
|------|------|
| `join()` | 대상 쓰레드가 종료될 때까지 무한 대기 |
| `join(ms)` | 주어진 시간만큼만 대기 후 실행 계속 |

---

## 섹션 5. 스레드 제어와 생명 주기2

### 인터럽트

- `interrupt()`를 호출하면 `WAITING`, `TIMED_WAITING` 같은 **대기 상태의 쓰레드를 깨워서 `RUNNABLE` 상태로 만들 수 있음.**
- 단, `interrupt()` 호출만으로 즉시 `InterruptedException`이 발생하지는 않음  
  → `sleep()` 같은 **예외를 던지는 메서드**가 호출되거나 호출 중일 때만 예외 발생함

#### 인터럽트 상태 처리

- 쓰레드에서 **인터럽트 예외가 한 번 발생하면**, 인터럽트 상태가 `false`로 바뀜
- **인터럽트의 목적을 달성했으면 상태를 다시 정상으로 돌려줘야 함**

| 메서드 | 설명 |
|--------|------|
| `isInterrupted()` | 인터럽트 상태를 확인만 함 (상태 변경 x) |
| `Thread.interrupted()` | 인터럽트 상태를 확인하고, 상태를 `false`로 초기화 |

---

### 프린터 예제

- **`volatile`**: 여러 쓰레드가 동시에 접근하는 변수에 붙이면 **가시성 문제를 해결함**
- **`ConcurrentLinkedQueue`**: 동시성을 지원하는 **컬렉션**, 여러 쓰레드가 안전하게 접근 가능

→ 예제에서는 프린터 큐 작업을 처리하면서 인터럽트를 적용해 쓰레드 안전성과 응답성을 높임

---

### yield() - 양보하기

운영체제가 어떤 쓰레드를 얼마나 실행시킬지는 **스케줄링 정책에 따라 결정됨**.  
특정 쓰레드가 바쁘지 않을 경우, **다른 쓰레드에 CPU 실행 기회를 양보할 수 있음.**

#### 주요 메서드 비교

| 방식 | 설명 | 상태 변화 |
|------|------|------------|
| **empty** | 그냥 자기 일만 쭉 하고 끝냄 | 없음 |
| **sleep(ms)** | 명시적으로 휴식 → 실행 제외 | `RUNNABLE → TIMED_WAITING → RUNNABLE` |
| **yield()** | 양보하고 다시 대기열에 들어감 | `RUNNABLE 유지` |

#### yield() 특징

- `Thread.yield()`는 현재 쓰레드가 **자발적으로 CPU 양보**
- 양보한 쓰레드는 여전히 `RUNNABLE` 상태로 남아서 **다시 스케줄링 큐에 진입**
- 만약 **양보 받을 쓰레드가 없으면**, 본인 쓰레드가 계속 실행될 수도 있음

---
